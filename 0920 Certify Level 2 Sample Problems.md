# C言語ﾌﾟﾛｸﾞﾗﾐﾝｸﾞ能力検定2級サンプル問題　解答調べ
* 問１
⑴古いC言語規格では型宣言しない場合は暗黙的にint型として扱われていたが、現在のC言語（C99規格以降）では、関数の型宣言をしない場合はエラーになる。
⑵自作ヘッダファイルの中でstdio.h等別のヘッダファイルを#includeすることは一般的。ただし二重インクルードを防ぐためにインクルードガードでセットで使う。
⑶constはconstantの略。「定数、不変の、一定の」の意味がある。
const修飾子は変数を読み取り専用にする。
constは左隣のものを修飾、何も無い場合は右隣を修飾する。
const double PI = 3.14159;
const int *p = &a;intが修飾され間接参照でa値の変更が不可
int * const p = &a; *が修飾されポインタの指す住所変更が不可
⑷atoiは「ASCII to int」の略。
数字文字列を整数型に変換する。ex:" +123abc"→+123
使うにはstdio.hをインクルードする。
int atoi(char *str)の様に使う。
⑹予約語「for」等。
char_name_for_user[100];はOK。
int forはNG。
⑻戻り値をvoidで指定した場合は、コンパイラに「この関数は、呼び出し元に値を一切返しません」と宣言したのと同じ。なのでretutn 5;等と書くとエラーになる。
ただreturn;のみは書けるが、処理の中断を意味する。
関数の中で外部変数(グローバル変数)と同じ名前の局所変数（ローカル変数）を宣言することは出来る。
より内側のスコープで宣言された変数が、外側のスコープの同名の変数より優先される（コンパイラは変数を内側スコープから参照する）
ただしコードが紛らわしくなるので避ける方が良い。

* 問2
enumは、enumrationの略。列挙すると言う意味。
e「外へ」＋numerus「数（number）」で箱の中から一つ一つ数え上げるイメージ。
enum signal {RED,YELLOW,BLUE}の様に使う。数字の集まりに意味のある名前を付けることが出来る。先に｛0,1,2...｝リストがあって、それに名前を付けてあげるイメージ。可読性が上がる。
デフォルトでは０から＋１される。＝で指定するとそこが新しい開始点となって、そこから＋１されていく。列挙定数に同じ値を割り当てることも可能。

* 問3
strlen()は実行時に内容を調べる関数。
sizeof()はコンパイル時にサイズを調べる演算子。
strlen()は\0の手前までの文字数を数える。
sizeofz()は配列全体に割り当てられたメモリサイズを数える。\0も1バイトのデータとして数える。文字列は終端に\0が自動追加される

* 問4
ビット演算子は数値を10進数ではなく、2進数で扱い、ビット単位で操作をする為に使う。
「&（AND/論理積）」「|(OR/論理和)」「^（XOR/排他的論理和）」「~(NOT/ビット反転)」「<<（左シフト）」「>>（右シフト）」
「^」読みはキャレット。天秤^の形で2つのビットを比べて違っていれば「1」。
scanf("%[^\n]",str);での「^」は文字列を扱う別のルールが適応されて「\n（この文字）以外の」の意味になる。
int result = a ^ b;の様に2つの整数変数の間で使われる時XORになる。文脈で意味が変わるイメージ。
「~」チルダ。～波の形でひっくり返すイメージ。
intの様な符号付整数でビット反転を行うと2の補数つまり負の数になる。※1の補数にすると０が+0と-0二つあることになる。+1,+0,-1という並び。
int a = 12;0000...00001100→
result = ~a;1111...11110011、~a＝-13になる。
-aは-12。-a=(~a - 1)

* 問5
argumentは口論ではなく、引数と言う意味。argumentの元になった言葉には、自分の主張の正しさを証拠を掲示して明らかにする意味がある。日本語では関数に「引き渡す数」で引数だが、英語にはargumentを渡して関数の仕事内容を「明らかにする」意味がある。
argcは引数の数を数える。自身も数えるのでカウント1からスタート
argvは、渡された引数を格納したポインタの配列。
int main(int argc,char *argv[])の様に書く。

* 問6
*p+1では間接参照→+1の順で実行される。
*(p+1)なら格納したアドレスの次のアドレスの値を参照する。
「->」はアロー演算子。(*ポインタ).メンバを読みやすくしたもの。
struct Item a;
a.price =100;なら分かりやすくて良いが、ポインタしかない時は
struct Item *p;//Item構造体へのポインタ。pにアドレスが入る
(*p).price = 100;//優先順位の関係で()で囲む必要がある。
p->price = 100;//.は*より優先順位が高い。
※殆どの演算子は（~,^,->,+,*など）はコンパイル時に解釈され、実行時に計算される。sizeofは例外でコンパイル時に計算まで完了する