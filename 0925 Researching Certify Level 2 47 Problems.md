--1006追記
*　問1
⑶
数字の後ろに付ける文字を「サフィックス(Suffix)（接尾辞）」と呼ぶが、それを付けることで、
その定数がどの型であるか明示的に示すことが出来る。接頭辞はprefix。これの対義語。
suf(sub)+fixで下に固定する取り付ける意味が核。それが言語変化させる部分を指す様になった。
「1」「123」の様に何も付けずに整数を書くと、デフォルトでint型として扱われる。
（intに収まらない長大な数字はlong int/long long long int）。
「1L」の様に書くと、これはｺﾝﾊﾟｲﾗにlong型の1ですよ。と伝えていることになる。
1lの様に小文字lでも可能だが、人間の判別なために大文字Lで書くことが推奨されている。
「123,123L,123LL,123U,123UL,123ULL」
⑸
「sprintf()」「printf()」どちらとも＜stdio.h＞で定義されている。
printf(print formattedの略)標準出力。通常ｺﾝｿｰﾙに出力される。
srintf(string print formatted)出力先はchar型の配列、つまり文字列。
sprintf(char *buffer,const char *format,.......);の様に書き、
一番目の引数に書き込み先の「文字配列」を指定する。書き込み先なのでポインタかアドレス情報で渡す？
  char buffer[100];
  printf("printfの出力：%d年%d月%d日",year,month,day);
  sprint(buffer,"%d年%d月%d日",year,month ,day);&buffer[0]が書き込み先として指定されている。
  printf("sprintfが書き込んだ文字列：％s\n",buffer);
上のように一度変数に文字列(buffer[])を作成しておいて、後からその文字列を使いたい、
と言う場面で役に立つ。
ただsprintfは書き込み先のサイズをチェックしない欠陥があり、バッファオーバーフローの危険があり、
現在は第二引数にバッファ最大サイズを指定できるsnprintf()を使うのが常識になっている。
⑺
「rand()」は疑似乱数というランダムに見える数値を生成するための関数。
stdlib.hをｲﾝｸﾙｰﾄﾞする必要がある。rando()を呼び出すと、０からRAND_MAX(環境によって変わる。例：32767など)までの範囲の整数がランダムに返される。
#include<stdio.h>
#include<stdlib.h>
int main(void){
  printf("%d\n",rand());
  printf("%d\n",rand());
  return 0;
}のように書ける、がこれだと何度実行しても同じ値が出てしまう。
rand()が生成する値はある計算式から作られている。その最初の計算式を「seed(種)」と呼ぶ。
種が同じだとそこから作られる数列は必ず同じになる。デフォルト値は常に同じ(１)なので毎回同じ結果になる。
では毎回違う乱数を生成するには？
プログラムを実行する度に毎回違う種をrand()に与える必要がある。
１．srand()関数：種を設定するための関数。ｓはseedのｓ。
２．time()関数：time(NULL)を呼び出すと１９７０年１月１日からの経過秒数が返される。
これは常に変化する値なのでseedに適している。<time.h>のインクルードが必要。
#include<stdio.h>
#include<stdlib.h>
#include<time.h>
int main(void){
  srand((unsigned int)time(NULL));現在時刻を種として乱数生成器を初期化
  printf("%d\n",rand());これ以降に呼び出すrand()は毎回違う値を返すようになる。
  ただrand()が返す値はそのままでは大きすぎるので、
  rand()%10 10で割った余りは必ず０～９になる。
  rand()%10+1　１～10の乱数
  rand()%6+1　 １～６のサイコロの様に余りを活用することが多い。
}
⑺　問1
⑶
数字の後ろに付ける文字を「サフィックス(Suffix)（接尾辞）」と呼ぶが、それを付けることで、
その定数がどの型であるか明示的に示すことが出来る。接頭辞はprefix。これの対義語。
suf(sub)+fixで下に固定する取り付ける意味が核。それが言語変化させる部分を指す様になった。
「1」「123」の様に何も付けずに整数を書くと、デフォルトでint型として扱われる。
（intに収まらない長大な数字はlong int/long long long int）。
「1L」の様に書くと、これはｺﾝﾊﾟｲﾗにlong型の1ですよ。と伝えていることになる。
1lの様に小文字lでも可能だが、人間の判別なために大文字Lで書くことが推奨されている。
「123,123L,123LL,123U,123UL,123ULL」
⑸
「sprintf()」「printf()」どちらとも＜stdio.h＞で定義されている。
printf(print formattedの略)標準出力。通常ｺﾝｿｰﾙに出力される。
srintf(string print formatted)出力先はchar型の配列、つまり文字列。
sprintf(char *buffer,const char *format,.......);の様に書き、
一番目の引数に書き込み先の「文字配列」を指定する。書き込み先なのでポインタかアドレス情報で渡す？
  char buffer[100];
  printf("printfの出力：%d年%d月%d日",year,month,day);
  sprint(buffer,"%d年%d月%d日",year,month ,day);&buffer[0]が書き込み先として指定されている。
  printf("sprintfが書き込んだ文字列：％s\n",buffer);
上のように一度変数に文字列(buffer[])を作成しておいて、後からその文字列を使いたい、
と言う場面で役に立つ。
ただsprintfは書き込み先のサイズをチェックしない欠陥があり、バッファオーバーフローの危険があり、
現在は第二引数にバッファ最大サイズを指定できるsnprintf()を使うのが常識になっている。
⑺
「rand()」は疑似乱数というランダムに見える数値を生成するための関数。
stdlib.hをｲﾝｸﾙｰﾄﾞする必要がある。rando()を呼び出すと、０からRAND_MAX(環境によって変わる。例：32767など)までの範囲の整数がランダムに返される。
#include<stdio.h>
#include<stdlib.h>
int main(void){
  printf("%d\n",rand());
  printf("%d\n",rand());
  return 0;
}のように書ける、がこれだと何度実行しても同じ値が出てしまう。
rand()が生成する値はある計算式から作られている。その最初の計算式を「seed(種)」と呼ぶ。
種が同じだとそこから作られる数列は必ず同じになる。デフォルト値は常に同じ(１)なので毎回同じ結果になる。
では毎回違う乱数を生成するには？
プログラムを実行する度に毎回違う種をrand()に与える必要がある。
１．srand()関数：種を設定するための関数。ｓはseedのｓ。
２．time()関数：time(NULL)を呼び出すと１９７０年１月１日からの経過秒数が返される。
これは常に変化する値なのでseedに適している。<time.h>のインクルードが必要。
#include<stdio.h>
#include<stdlib.h>
#include<time.h>
int main(void){
  srand((unsigned int)time(NULL));現在時刻を種として乱数生成器を初期化
  printf("%d\n",rand());これ以降に呼び出すrand()は毎回違う値を返すようになる。
  ただrand()が返す値はそのままでは大きすぎるので、
  rand()%10 10で割った余りは必ず０～９になる。
  rand()%10+1　１～10の乱数
  rand()%6+1　 １～６のサイコロの様に余りを活用することが多い。
}
⑺
「strcat()関数」はstring catenateの略で、第一引数の文字列の「末尾に」、第二引数の文字列を「連結する」
為の関数。strcpy()が上書きコピーで、strcat()が追加コピーと覚える。<string.h>が必要。
char *strcat(char *destination, const char *source);
#include<stdio.h>
#include<string.h>
int main(void){
  char dest[50]="Hello, ";
  char src[]="World!";
  strcat(dest,src);の様に使う。
}strcat()はdestの末尾の￥0を探して、その場所からsrcの文字を貼りつけ始め最後にsrcの￥0もコピーする。
ﾊﾞｯﾌｧｵｰﾊﾞｰﾌﾛｰを防ぐ為に「strncat()」srcから最大何文字コピーしてくるか決められる関数の方が推奨される。
⑻
if(a<b)　min=a;　else　min=b;は、
min=(a<b)?a:b;の様に記述出来るか？
⇒出来る。「?:」と言う書き方は「条件演算子」または「三項条件演算子」と呼ばれる。
if-else文では書けないような場所でも同様の動作を記述することが出来る。
printf("小さい方の値は、%dです。\n",(a<b)?a:b);とprintfの中で直接使うことが出来る。

* 問2
ファイル関連の関数について。
fopen()でファイルを開いてから、fgets()でそのファイルを読み込む、と言う様にセットで使う。
fopen()が返すFILE*はどのファイルを開いているかのしおりの様なもの
fgets()の最後の「s」はstringのs。開いたファイルから1行分読み取る。
ファイル関連の主要な関数と用語について
１．３つの標準ストリーム（情報の出入り口）
ｃ言語のプログラムを実行すると、自動的に3つの情報の出入り口(ストリーム)が用意される。FILE型だがfopenする必要は無い。
「stdin」:FILE型。標準入力。通常はｷｰﾎﾞｰﾄﾞからの入力を指す。ﾌﾟﾛｸﾞﾗﾑへの入力口
「stdout」:FILE型。標準出力。通常はｺﾝｿｰﾙ画面への出力を指す。ﾌﾟﾛｸﾞﾗﾑからの通常出口。
「stderr」: FILE型。標準エラー出力。エラーメッセージ専用の出力先。ﾌﾟﾛｸﾞﾗﾑからの非常口。
２．１文字単位の入出力
「fgetc(fp)」:fpが指すﾌｧｲﾙから「1」文字読込、その文字コード(int型)を、ﾌｧｲﾙ終端ならEOFを返す。
「fputc(ch, fp)」:fpが指すファイルに、文字「ch」を1文字書き込む。fputc('A',fp)の様に使う。
「ungetc(ch, fp)」:Un-get-Characterの略。fgetc等で一度読み込んだ文字「ch」を、ストリームに「1文字だけ」戻す特殊な関数。戻された文字は、次に読込が行われる時に再度読み込まれる。「今の文字は見たけれど、やっぱり読まなかったことにしたい」と言う動作になる。
３．文字列の入出力
「fputs(str, fp)」:fpが指すﾌｧｲﾙに文字列strを書き込む。putsと違い\nは自動では追加されない。
なので、fputs("Hello\n",fp);の様に書く。
４．書式付きの入出力
「fprintf(fp, format, ...)」：printfのﾌｧｲﾙ版。fpが指すﾌｧｲﾙにformatで指定した書式で文字列を書き込む。
fprintf(fp, "Name:%s, Score:%d\n",name, score);の様に書く。
「fscanf(fp, format, ...)」：scanfのﾌｧｲﾙ版。fpが指すﾌｧｲﾙから、formatで指定した書式でﾃﾞｰﾀを読み取り、
変数に格納する。fscanf(fp, "%s %d", name, &score);の様に使う。
５．ファイル管理
「fclose(fp)」：fopenで開いたファイルとの接続(ｽﾄﾘｰﾑ)を閉じる。ﾌｧｲﾙ操作の終わりに必ず呼び出すこと。
それはなぜか。１つが「バッファのフラッシュ（書込みの確定)」の為。コンピュータは処理を高速化するために、fprintfなどで書込み指示されたデータを、「すぐにHDには書き込まない」。一旦メモリ上にある「バッファ」と呼ばれる一時的な待機場所にデータを溜め込み、ある程度の量溜まったらまとめてディスクに書き込む。
fcloseが持つ最も重要な役割は、プログラムが終わる際に、このバッファにまだ残っているデータを「強制的にすべて補助記憶装置に書込むこと」。これをフラッシュすると言う。
もう１つがファイル操作権限の解放の為。fopenでﾌｧｲﾙを開くとOSからﾌｧｲﾙ操作する為の権限(ファイルハンドル)を借りる。OSには同時に開けるファイル数の上限があるため、これは有限のリソース。fcloseを忘れて多数のファイルを開き続けると、やがてリソースを使い果たし、新しいファイルを開けなくなってしまう。

* 問３
#include<stdio.h>
int main(void){
    unsigned short a = 0xf3ea;
    unsigned short b = 0x7de5;
  
    printf("%04hx\n",a&b);
  /*「%」書式指定子の開始を知らせる記号。
  「0」ｾﾞﾛﾊﾟﾝﾃﾞｨﾝｸﾞ指定した桁数に満たない場合は「0」で埋めるというフラグ。
  「4」最小の桁数指定。最低でも4桁で表示する。
  「h」short型であることを示す「長さ修飾子」。
  「x」数値を16進数(hexadecimal)の「小文字で」表示する指定。
  ⇒「short型の値を最低4桁の16進数で足りない桁は0で埋めて表示する」という意味。
  0xf3ea⇒1111 0011 1110 1010
  0z7de5⇒0111 1101 1110 0101
          0111 0001 1110 0000⇒0x71e0*/
    printf("%04hx\n",a^0xff00,); /*「a」と「0xff00」の「^」排他的論理和
  1111 0011 1110 1010
  1111 1111 0000 0000
  0000 1100 1110 1010⇒0x0cea*/
    printf("%04hx\n",b<<5,);/*bを5ビット「左シフト」する
  0111 1101 1110 0101
  1011 1100 1010 0000⇒0xbca0*/
    printf("%04hx\n",~a|(b<<1),);/*「a」を「~」ビット反転したものと、bを1ビット左シフトして論理和
  1111 0011 1110 1010
  0000 1100 0001 0101
 01111 1011 1100 1010
  1111 1111 1101 1111⇒0xffdf*/
    printf("%04hx\n",(a&0x0ff0)|(b<<12));
  /*「a&0x0ff0」aの中間ビットだけを残す。bを左12ビットシフトしたものと論理和
  0111 1101 1110 0101 0000 0000 0000
                 0000 0011 1110 0000
                 0101 0011 1110 0000⇒0x53e0*/
    return 0;  
}
■書式指定子と演算子についてまとめ
１．主な書式指定子
整数型：「%d,%---int符号付10進数」「%u---unsigned int符号なし10進数」
       「%x,%X---int16進数(小/大文字)」「%o---8進数」
浮動小数点型：「%f---double小数点形式：printf()内ではfloat4バイトはdouble8バイトに自動変換される」
              ※scanf()で使う場合は書き込む先の変数がfloatかdoubleか区別する必要がある。%f/%lfと書く
            *「%e,%E---double指数形式(例:1.23+02:1.23×10の2乗の意味：expention(指数の略)」
             *「%g,%G---double:%fか%eの短い方を選択：generalの略」
文字・文字列型：「%c---int/char：文字コード/1文字」「%s---char*文字列(文字配列の先頭要素アドレス)」
*ﾎﾟｲﾝﾀ型：「%dp---void*ﾎﾟｲﾝﾀのアドレス」
２．書式指定子のオプション(フラグ・修飾子)フラグは目印のこと。
  *フラグ：「-」左詰めで表示(%-10d)「+」正の数にも+記号を付けて表示(%+d)「0」空白の代わりに0で埋める。
  桁数指定：「%10d」最低10桁分の幅を確保して表示
  精度指定：「.」(%.2f)浮動小数点。小数点以下の桁数を指定。
  文字列：(%.5s)%sで「.」が使われたときは、表示する最大文字数を指定
  長さ修飾子「h」(%hd)short int型2バイトであることを示す：2バイト：約±3万：intは：4バイト：約±21億
  　　　　　「l」---%ld,%lf:long int型やdouble(scanf時)であることを示す。４または8バイト：環境による
           「ll---%lld:long long int型」8バイト：約±992京：unsigned shortは2バイト：約6万5千…ﾄﾞﾗｸｴ
＃＃C言語の主な演算子
１．算術演算子：「+」「-」「*」「/」「%」「++/--」ｲﾝｸﾘﾒﾝﾄ/ﾃﾞｸﾘﾒﾝﾄ
２．関係演算子・等価演算子：if文などの条件式で使い、結果が「真(１)」又は「偽(０)」になる。
「=/!=」「>\<」「>=/<=」
３．論理演算子：複数条件式を組み合わせるときに使う。
「&&---AND:例(a>0)&&(b>0)」「||---OR:例(a==0)||(b==0)」*「!---NOT(でない):例 !(a==0)」
*４．ビット演算子：ビット単位で論理演算を行う。
「&---論理積」「|---論理和」*「^---排他的論理和(scanfの中では意味が変わることもある)」
*「~---NOTビット反転」「<</>>---左シフト/右シフト」
５．代入演算子
「=---代入」「+=---加算して代入」「-=---減算して代入」
「*=,/=,%=---乗算,除算,剰余して代入」「&=---ビット演算子して代入」「<<=,>>=---シフトして代入」
６．そのほかの重要な演算子
「sizeof---サイズをバイト単位で取得」「(型)---キャスト(型変換)」*「?:---条件演算子(三項演算子)」
「.---ex:data.member(構造体/共有体のメンバ)」
「->---アロー演算子：構造体共有体ﾎﾟｲﾝﾀのメンバ:ex:ptr->member」「&---ｱﾄﾞﾚｽ取得」
「*---間接参照(ﾎﾟｲﾝﾀの中身にアクセス):*ptr」

* 問５
#include<stdio.h>
#include<stdlib.h>
int main(void){
             num[0],  [1], [2], [3], [4]
  char *num[]={"52","-21","38","17","-40"};
  /*numと言う名前のﾎﾟｲﾝﾀ配列が用意される。各要素には数字の「文字列リテラル」の先頭ｱﾄﾞﾚｽが格納*/
  double d;
  printf("%d\n",atoi(num[2]));//atoi()で文字列を数値に変換
  printf("%d\n",abs(atoi(num[1])));//abs()は整数の絶対値を返す(absolute valueの略)結果は21
  printf("%d\n",abs(atoi(num[3]))-abs(atoi(num[4])));//17－40＝－23
  d = atof("-1.374")+0.5;//アスキー文字列数値を注意float型ではなくdouble型に変換する。
  d =d*100.0;//-0.874*100.0=-87.4
  printf("%.1f\n",d);//小数点一桁まで表示
  return 0;
}

*問6
#include<stdio.h>
int main(void){
  char *flowers[]={"ROSE","TULIP","PANSY","LILY","COSMOS"};//char型ﾎﾟｲﾝﾀ配列の宣言
  char *p, **pp;//「char *p」は文字を指すﾎﾟｲﾝﾀ。
  p =flowers[1];//ﾎﾟｲﾝﾀ配列の2番目要素、つまり文字列"TULIP"の先頭アドレスを指すﾎﾟｲﾝﾀ。'T'を指している
  printf("%s\n",p);//書式指定子が%sなのでpが指すｱﾄﾞﾚｽから\0までを読み込んで表示。つまりTULIPが出力
  p += 2; //⚠char*型のﾎﾟｲﾝﾀpに＋２しているので、ﾎﾟｲﾝﾀが2文字分進む。'L'を指す。
  printf("%s\n",p);//%sは渡されたｱﾄﾞﾚｽから\0までを読み込んで表示するので、LIPと出力。
  pp = &flowers[2];
  /*char **ppは『「文字へのﾎﾟｲﾝﾀ」を指すﾎﾟｲﾝﾀ』。flowers[2]は文字列"PANSY"を指すchar*型のﾎﾟｲﾝﾀ。
  ＆flowers[2]は、そのﾎﾟｲﾝﾀが格納されている配列の3番目スロットそのもののｱﾄﾞﾚｽを取得する。
  配列名flowers[2]だけでアドレス情報を含んでいるので(文字列"PANSY"の先頭'p'のアドレスを指している)、
  &を付けて&flowers[2]とすることで、&*ptrと書くのと同じ意味になり、ﾎﾟｲﾝﾀ自体のｱﾄﾞﾚｽ、つまり*flowers[]ﾎﾟｲﾝﾀ配列の3番目の場所(スロット自体)を指していることになる。*/
  printf("%s\n",*pp);//char型のﾎﾟｲﾝﾀのﾎﾟｲﾝﾀ型が間接参照で見るのは配列"PANSY"の先頭要素ｱﾄﾞﾚｽ。%sなので
                      //そのｱﾄﾞﾚｽの指す文字から\0まで読み込んで表示⇒PANSYと出力
  printf("%s\n",*(pp+1));//char**型ﾎﾟｲﾝﾀppに1足すとflowers[3]をつまりchar*型配列の4番目の要素を指す
  printf("%c\n",**pp);//ﾎﾟｲﾝﾀのﾎﾟｲﾝﾀの指す場所を間接参照するので、flower[3]の配列"PANSY"の先頭ｱﾄﾞﾚｽ
                      //が参照されて'P'が返される。
  return 0;
/*配列名flowersという配列そのものが、式の中ではppと同じchar**型として扱われるのでややこしい。
配列flowers自体は一次ﾎﾟｲﾝﾀを収納している一次ﾎﾟｲﾝﾀ型の配列の様な記述だけれど、配列にするということは先頭要素アドレスで扱うということなので、アドレス情報を格納している配列というアドレス情報を持った固まりになる。つまりﾎﾟｲﾝﾀのﾎﾟｲﾝﾀと同じ。そもそも一次ﾎﾟｲﾝﾀを格納出来ている時点でﾎﾟｲﾝﾀのﾎﾟｲﾝﾀ型と同じと言えるのだけれど、式の中での記述がflowers[]だけで*が消えてしまっているからややこしい。
flowersと書くだけで、目には見えない*が一つ補われてchar**として扱われる。この暗黙のルールがややこしい。
*/












