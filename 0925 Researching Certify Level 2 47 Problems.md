--1006追記
*　問1
⑶
数字の後ろに付ける文字を「サフィックス(Suffix)（接尾辞）」と呼ぶが、それを付けることで、
その定数がどの型であるか明示的に示すことが出来る。接頭辞はprefix。これの対義語。
suf(sub)+fixで下に固定する取り付ける意味が核。それが言語変化させる部分を指す様になった。
「1」「123」の様に何も付けずに整数を書くと、デフォルトでint型として扱われる。
（intに収まらない長大な数字はlong int/long long long int）。
「1L」の様に書くと、これはｺﾝﾊﾟｲﾗにlong型の1ですよ。と伝えていることになる。
1lの様に小文字lでも可能だが、人間の判別なために大文字Lで書くことが推奨されている。
「123,123L,123LL,123U,123UL,123ULL」
⑸
「sprintf()」「printf()」どちらとも＜stdio.h＞で定義されている。
printf(print formattedの略)標準出力。通常ｺﾝｿｰﾙに出力される。
srintf(string print formatted)出力先はchar型の配列、つまり文字列。
sprintf(char *buffer,const char *format,.......);の様に書き、
一番目の引数に書き込み先の「文字配列」を指定する。書き込み先なのでポインタかアドレス情報で渡す？
  char buffer[100];
  printf("printfの出力：%d年%d月%d日",year,month,day);
  sprint(buffer,"%d年%d月%d日",year,month ,day);&buffer[0]が書き込み先として指定されている。
  printf("sprintfが書き込んだ文字列：％s\n",buffer);
上のように一度変数に文字列(buffer[])を作成しておいて、後からその文字列を使いたい、
と言う場面で役に立つ。
ただsprintfは書き込み先のサイズをチェックしない欠陥があり、バッファオーバーフローの危険があり、
現在は第二引数にバッファ最大サイズを指定できるsnprintf()を使うのが常識になっている。
⑺
「rand()」は疑似乱数というランダムに見える数値を生成するための関数。
stdlib.hをｲﾝｸﾙｰﾄﾞする必要がある。rando()を呼び出すと、０からRAND_MAX(環境によって変わる。例：32767など)までの範囲の整数がランダムに返される。
#include<stdio.h>
#include<stdlib.h>
int main(void){
  printf("%d\n",rand());
  printf("%d\n",rand());
  return 0;
}のように書ける、がこれだと何度実行しても同じ値が出てしまう。
rand()が生成する値はある計算式から作られている。その最初の計算式を「seed(種)」と呼ぶ。
種が同じだとそこから作られる数列は必ず同じになる。デフォルト値は常に同じ(１)なので毎回同じ結果になる。
では毎回違う乱数を生成するには？
プログラムを実行する度に毎回違う種をrand()に与える必要がある。
１．srand()関数：種を設定するための関数。ｓはseedのｓ。
２．time()関数：time(NULL)を呼び出すと１９７０年１月１日からの経過秒数が返される。
これは常に変化する値なのでseedに適している。<time.h>のインクルードが必要。
#include<stdio.h>
#include<stdlib.h>
#include<time.h>
int main(void){
  srand((unsigned int)time(NULL));現在時刻を種として乱数生成器を初期化
  printf("%d\n",rand());これ以降に呼び出すrand()は毎回違う値を返すようになる。
  ただrand()が返す値はそのままでは大きすぎるので、
  rand()%10 10で割った余りは必ず０～９になる。
  rand()%10+1　１～10の乱数
  rand()%6+1　 １～６のサイコロの様に余りを活用することが多い。
}
⑺　問1
⑶
数字の後ろに付ける文字を「サフィックス(Suffix)（接尾辞）」と呼ぶが、それを付けることで、
その定数がどの型であるか明示的に示すことが出来る。接頭辞はprefix。これの対義語。
suf(sub)+fixで下に固定する取り付ける意味が核。それが言語変化させる部分を指す様になった。
「1」「123」の様に何も付けずに整数を書くと、デフォルトでint型として扱われる。
（intに収まらない長大な数字はlong int/long long long int）。
「1L」の様に書くと、これはｺﾝﾊﾟｲﾗにlong型の1ですよ。と伝えていることになる。
1lの様に小文字lでも可能だが、人間の判別なために大文字Lで書くことが推奨されている。
「123,123L,123LL,123U,123UL,123ULL」
⑸
「sprintf()」「printf()」どちらとも＜stdio.h＞で定義されている。
printf(print formattedの略)標準出力。通常ｺﾝｿｰﾙに出力される。
srintf(string print formatted)出力先はchar型の配列、つまり文字列。
sprintf(char *buffer,const char *format,.......);の様に書き、
一番目の引数に書き込み先の「文字配列」を指定する。書き込み先なのでポインタかアドレス情報で渡す？
  char buffer[100];
  printf("printfの出力：%d年%d月%d日",year,month,day);
  sprint(buffer,"%d年%d月%d日",year,month ,day);&buffer[0]が書き込み先として指定されている。
  printf("sprintfが書き込んだ文字列：％s\n",buffer);
上のように一度変数に文字列(buffer[])を作成しておいて、後からその文字列を使いたい、
と言う場面で役に立つ。
ただsprintfは書き込み先のサイズをチェックしない欠陥があり、バッファオーバーフローの危険があり、
現在は第二引数にバッファ最大サイズを指定できるsnprintf()を使うのが常識になっている。
⑺
「rand()」は疑似乱数というランダムに見える数値を生成するための関数。
stdlib.hをｲﾝｸﾙｰﾄﾞする必要がある。rando()を呼び出すと、０からRAND_MAX(環境によって変わる。例：32767など)までの範囲の整数がランダムに返される。
#include<stdio.h>
#include<stdlib.h>
int main(void){
  printf("%d\n",rand());
  printf("%d\n",rand());
  return 0;
}のように書ける、がこれだと何度実行しても同じ値が出てしまう。
rand()が生成する値はある計算式から作られている。その最初の計算式を「seed(種)」と呼ぶ。
種が同じだとそこから作られる数列は必ず同じになる。デフォルト値は常に同じ(１)なので毎回同じ結果になる。
では毎回違う乱数を生成するには？
プログラムを実行する度に毎回違う種をrand()に与える必要がある。
１．srand()関数：種を設定するための関数。ｓはseedのｓ。
２．time()関数：time(NULL)を呼び出すと１９７０年１月１日からの経過秒数が返される。
これは常に変化する値なのでseedに適している。<time.h>のインクルードが必要。
#include<stdio.h>
#include<stdlib.h>
#include<time.h>
int main(void){
  srand((unsigned int)time(NULL));現在時刻を種として乱数生成器を初期化
  printf("%d\n",rand());これ以降に呼び出すrand()は毎回違う値を返すようになる。
  ただrand()が返す値はそのままでは大きすぎるので、
  rand()%10 10で割った余りは必ず０～９になる。
  rand()%10+1　１～10の乱数
  rand()%6+1　 １～６のサイコロの様に余りを活用することが多い。
}
⑺
「strcat()関数」はstring catenateの略で、第一引数の文字列の「末尾に」、第二引数の文字列を「連結する」
為の関数。strcpy()が上書きコピーで、strcat()が追加コピーと覚える。<string.h>が必要。
char *strcat(char *destination, const char *source);
#include<stdio.h>
#include<string.h>
int main(void){
  char dest[50]="Hello, ";
  char src[]="World!";
  strcat(dest,src);の様に使う。
}strcat()はdestの末尾の￥0を探して、その場所からsrcの文字を貼りつけ始め最後にsrcの￥0もコピーする。
ﾊﾞｯﾌｧｵｰﾊﾞｰﾌﾛｰを防ぐ為に「strncat()」srcから最大何文字コピーしてくるか決められる関数の方が推奨される。
⑻
if(a<b)　min=a;　else　min=b;は、
min=(a<b)?a:b;の様に記述出来るか？
⇒出来る。「?:」と言う書き方は「条件演算子」または「三項条件演算子」と呼ばれる。
if-else文では書けないような場所でも同様の動作を記述することが出来る。
printf("小さい方の値は、%dです。\n",(a<b)?a:b);とprintfの中で直接使うことが出来る。

* 問2
ファイル関連の関数について。
fopen()でファイルを開いてから、fgets()でそのファイルを読み込む、と言う様にセットで使う。
fopen()が返すFILE*はどのファイルを開いているかのしおりの様なもの
fgets()の最後の「s」はstringのs。開いたファイルから1行分読み取る。
ファイル関連の主要な関数と用語について
１．３つの標準ストリーム（情報の出入り口）
ｃ言語のプログラムを実行すると、自動的に3つの情報の出入り口(ストリーム)が用意される。FILE型だがfopenする必要は無い。
「stdin」:FILE型。標準入力。通常はｷｰﾎﾞｰﾄﾞからの入力を指す。ﾌﾟﾛｸﾞﾗﾑへの入力口
「stdout」:FILE型。標準出力。通常はｺﾝｿｰﾙ画面への出力を指す。ﾌﾟﾛｸﾞﾗﾑからの通常出口。
「stderr」: FILE型。標準エラー出力。エラーメッセージ専用の出力先。ﾌﾟﾛｸﾞﾗﾑからの非常口。
２．１文字単位の入出力
「fgetc(fp)」:fpが指すﾌｧｲﾙから「1」文字読込、その文字コード(int型)を、ﾌｧｲﾙ終端ならEOFを返す。
「fputc(ch, fp)」:fpが指すファイルに、文字「ch」を1文字書き込む。fputc('A',fp)の様に使う。
「ungetc(ch, fp)」:Un-get-Characterの略。fgetc等で一度読み込んだ文字「ch」を、ストリームに「1文字だけ」戻す特殊な関数。戻された文字は、次に読込が行われる時に再度読み込まれる。「今の文字は見たけれど、やっぱり読まなかったことにしたい」と言う動作になる。
３．文字列の入出力
「fputs(str, fp)」:fpが指すﾌｧｲﾙに文字列strを書き込む。putsと違い\nは自動では追加されない。
なので、fputs("Hello\n",fp);の様に書く。
４．書式付きの入出力
「fprintf(fp, format, ...)」：printfのﾌｧｲﾙ版。fpが指すﾌｧｲﾙにformatで指定した書式で文字列を書き込む。
fprintf(fp, "Name:%s, Score:%d\n",name, score);の様に書く。
「fscanf(fp, format, ...)」：scanfのﾌｧｲﾙ版。fpが指すﾌｧｲﾙから、formatで指定した書式でﾃﾞｰﾀを読み取り、
変数に格納する。fscanf(fp, "%s %d", name, &score);の様に使う。
５．ファイル管理
「fclose(fp)」：fopenで開いたファイルとの接続(ｽﾄﾘｰﾑ)を閉じる。ﾌｧｲﾙ操作の終わりに必ず呼び出すこと。
それはなぜか。１つが「バッファのフラッシュ（書込みの確定)」の為。コンピュータは処理を高速化するために、fprintfなどで書込み指示されたデータを、「すぐにHDには書き込まない」。一旦メモリ上にある「バッファ」と呼ばれる一時的な待機場所にデータを溜め込み、ある程度の量溜まったらまとめてディスクに書き込む。
fcloseが持つ最も重要な役割は、プログラムが終わる際に、このバッファにまだ残っているデータを「強制的にすべて補助記憶装置に書込むこと」。これをフラッシュすると言う。
もう１つがファイル操作権限の解放の為。fopenでﾌｧｲﾙを開くとOSからﾌｧｲﾙ操作する為の権限(ファイルハンドル)を借りる。OSには同時に開けるファイル数の上限があるため、これは有限のリソース。fcloseを忘れて多数のファイルを開き続けると、やがてリソースを使い果たし、新しいファイルを開けなくなってしまう。

* 問３
#include<stdio.h>
int main(void){
    unsigned short a = 0xf3ea;
    unsigned short b = 0x7de5;
  
    printf("%04hx\n",a&b);
  /*「%」書式指定子の開始を知らせる記号。
  「0」ｾﾞﾛﾊﾟﾝﾃﾞｨﾝｸﾞ指定した桁数に満たない場合は「0」で埋めるというフラグ。
  「4」最小の桁数指定。最低でも4桁で表示する。
  「h」short型であることを示す「長さ修飾子」。
  「x」数値を16進数(hexadecimal)の「小文字で」表示する指定。
  ⇒「short型の値を最低4桁の16進数で足りない桁は0で埋めて表示する」という意味。
  0xf3ea⇒1111 0011 1110 1010
  0z7de5⇒0111 1101 1110 0101
          0111 0001 1110 0000⇒0x71e0*/
    printf("%04hx\n",a^0xff00,); /*「a」と「0xff00」の「^」排他的論理和
  1111 0011 1110 1010
  1111 1111 0000 0000
  0000 1100 1110 1010⇒0x0cea*/
    printf("%04hx\n",b<<5,);/*bを5ビット「左シフト」する
  0111 1101 1110 0101
  1011 1100 1010 0000⇒0xbca0*/
    printf("%04hx\n",~a|(b<<1),);/*「a」を「~」ビット反転したものと、bを1ビット左シフトして論理和
  1111 0011 1110 1010
  0000 1100 0001 0101
 01111 1011 1100 1010
  1111 1111 1101 1111⇒0xffdf*/
    printf("%04hx\n",(a&0x0ff0)|(b<<12));
  /*「a&0x0ff0」aの中間ビットだけを残す。bを左12ビットシフトしたものと論理和
  0111 1101 1110 0101 0000 0000 0000
                 0000 0011 1110 0000
                 0101 0011 1110 0000⇒0x53e0*/
    return 0;  
}









































