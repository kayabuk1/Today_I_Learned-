/*1011
どうやらﾎﾟｲﾝﾀの移動と、ﾎﾟｲﾝﾀのﾎﾟｲﾝﾀの移動の問題の出来が良くないので、実際に問題で出されたコードを書いてみる。
ﾎﾟｲﾝﾀを移動させたのか、ﾎﾟｲﾝﾀのﾎﾟｲﾝﾀを移動させたのか理解が曖昧なようだ。
自力でどんな風にコードを読み取ったのかコメントで記載するので、理解が間違っている箇所を指摘、解説してほしい。
*/
#include<stdio.h>
int main(void)
{
  char minst[][8]={"Violin","Cello","Flute","Trumpet"};
                  //char型2次元配列minstを定義。行は[3]の4要素。列は[8]の8要素+自動追加分\0
  char *p;  //char型ﾎﾟｲﾝﾀpの定義

  p= minst[2];      //pにminst[2]3番目char型配列"Flute"の先頭ｱﾄﾞﾚｽ代入(""で囲まれた文字列も内部的には先頭ｱﾄﾞﾚｽのみで扱われる)
  printf("%s\n",p);  　//pは"Flute"の先頭ｱﾄﾞﾚｽを指している。書式指定子は%s。自動追加の\0手前まで読み込んでcmdに出力。
  printf("%s\n",p+3);　//"Flute"の"F"を指しているﾎﾟｲﾝﾀを3進めるので、出力はte

  printf("%c\n",minst[3][1]);  //二次元配列minstの4行目2列目のアドレスの一文字を表示なので、r

  p =&minst[0][1];  //char配列ｱﾄﾞﾚｽ(文字列先頭ﾎﾟｲﾝﾀ)を格納するminst自体のアドレスをﾎﾟｲﾝﾀへ代入[0][1]なのでi
  printf("%s\n",p+3);  //iを指すﾎﾟｲﾝﾀを3要素分進める。ここではﾎﾟｲﾝﾀはminst自体のｱﾄﾞﾚｽ。なのでminst[3][1]でr    
  p++;                //pを1加算
  printf("%c\n",*p);   //pの指す[4][1]の文字の所へ行って文字を書き写して表示。なのだけれど、配列の上限を超えてしまっている？
  return 0;  
}
