/*1011
どうやらﾎﾟｲﾝﾀの移動と、ﾎﾟｲﾝﾀのﾎﾟｲﾝﾀの移動の問題の出来が良くないので、実際に問題で出されたコードを書いてみる。
ﾎﾟｲﾝﾀを移動させたのか、ﾎﾟｲﾝﾀのﾎﾟｲﾝﾀを移動させたのか理解が曖昧なようだ。
自力でどんな風にコードを読み取ったのかコメントで記載するので、理解が間違っている箇所を指摘、解説してほしい。
*/
#include<stdio.h>
int main(void)
{
  char minst[][8]={"Violin","Cello","Flute","Trumpet"};
                  //char型2次元配列minstを定義。行は[3]の4要素。列は[8]の8要素+自動追加分\0
  /*char minst[][8]の正体とは
  まずﾎﾟｲﾝﾀの配列(ex:char *flower[])と2次元配列(ex:char minst[][8])のメモリ上での構造が全く異なるのを理解出来ていない。
  char minst[][8]はメモリ上に4行×8列=32バイトの文字が隙間なく連続して並んでいる状態。
  minst[0]                 minst[1]           minst[2]             minst[3]
      　[V][i][o][l][i][n][\0]  [C][e][l][l][o][\0] [F][l][u][t][e][\0] [T][r][u][m][p][e][t][\0]
  ｱﾄﾞﾚｽ 1000...            1007 1008...        1015 1016           1023 1024                 1031
  */
  char *p;  //char型ﾎﾟｲﾝﾀpの定義

  p= minst[2];      //pにminst[2]3番目char型配列"Flute"の先頭ｱﾄﾞﾚｽ代入
                    //(""で囲まれた文字列も内部的には先頭ｱﾄﾞﾚｽのみで扱われる)
                    //minst[2]は3行目の配列名で配列名＝先頭要素ｱﾄﾞﾚｽなので**&minst[2][0]**に変換されて解釈される。
  
  printf("%s\n",p);  　//pのﾃﾞｰﾀ型はchar*なので文字自体のｱﾄﾞﾚｽを指している。
                      //書式指定子は%s。自動追加の\0手前まで読み込んでcmdに出力。
  printf("%s\n",p+3);　//pはchar*型なので文字自体のｱﾄﾞﾚｽを指している。
                        //"Flute"の"F"を指しているﾎﾟｲﾝﾀを3進めるので、出力はte

  printf("%c\n",minst[3][1]);  //二次元配列minstの4行目2列目のアドレスの一文字を表示なので、r

  p =&minst[0][1];  //char配列ｱﾄﾞﾚｽ(文字列先頭ﾎﾟｲﾝﾀ)を格納するminst自体のアドレスをﾎﾟｲﾝﾀへ代入[0][1]なのでi
  
  printf("%s\n",p+3);  //iを指すﾎﾟｲﾝﾀを3要素分進める。ここではﾎﾟｲﾝﾀはminst自体のｱﾄﾞﾚｽ。なのでminst[3][1]でr
                      //この動きはpがminstの様な二次元配列のﾎﾟｲﾝﾀだったらという話で、単なるchar*型のpでは違う
                      //char *p[][]と宣言？定義？されれば良いのかな？
                      //
/*ここから誤解ポイント
  「p」はchar*型なので2次元配列の構造(1行が8ﾊﾞｲﾄであること)を知らない。pにとっては単なる「32ﾊﾞｲﾄ」の連続した文字の列に見える
  pは、minst[0][1]=='i'==ｱﾄﾞﾚｽ1001番を指している。そこから3文字(3ﾊﾞｲﾄ)分進んだ場所を指す。
  'i'⇒'o'⇒'l'⇒'i'を指すそして書式指定子は%s。inが出力される
  */
  
  p++;                //pを1加算
  printf("%c\n",*p);   //pの指す[4][1]の文字の所へ行って文字を書き写して表示。なのだけれど、配列の上限を超えてしまっている？
                      //→間違い。printf()内での加算はpに+3した「一時的なｱﾄﾞﾚｽ」。
                      //もしprintf()内でp=p+3のように代入したらﾎﾟｲﾝﾀが進んだ状態になる？
                      //ので、pはまだ'i'を指していて。それを1進めるので答えは'o'
  return 0; 
}
//1011_P-47-Q6
#include<stdio.h>
int main(void)
{
  char *flowers[] = {"ROSE","TULIP","PANSY","LILY","COSMOS"};  //char型ではなく、char*型配列なのに注意？普通のchar型配列とはどう違う？
//⇒char minst[][8]はメモリ上に32バイトが一列に並んでいたが、char *flowers[]はﾎﾟｲﾝﾀ配列なので、配列flowers自体にはｱﾄﾞﾚｽ情報しか入っていない
//"ROSE"や"TULIP"はメモリ上の別の場所に存在する。
  
  char *p, **pp;    //char型の変数のｱﾄﾞﾚｽを格納するchar*型のﾎﾟｲﾝﾀpの定義。ﾎﾟｲﾝﾀのﾎﾟｲﾝﾀ型変数つまりchar**型変数ppを定義。

  p = flowers[1];    //flowers[1]==&flowers[1]==&"TULIP"なので、TULIPのアドレスを代入。
                    //間違い。&flowers[1]はアドレスのアドレス情報つまり、ﾎﾟｲﾝﾀのﾎﾟｲﾝﾀ型で型が違うので＝＝ではない。あと文字列自体に&はNG。
                    //シンプルに p = flowers[1];だけで"TULIP"の先頭ｱﾄﾞﾚｽが代入される。と考える。
  printf("%s\n", p );    //よってTULIPと表示
  p += 2;                //ﾎﾟｲﾝﾀ自身に2ｱﾄﾞﾚｽ分進める。char*型なので配列の配列とか知ったことなく２バイトだけ進める'T','U','L'よってLIP
  printf("%s\n", p );

  pp = &flowers[2];    //ﾎﾟｲﾝﾀのﾎﾟｲﾝﾀ型にTULIPが格納されている箱の場所、つまり配列flowers[2]のアドレスを書き込む
                     //**pp== *p == 'P'
                      //*pp==  p == flowers[2]
                       //pp == &flowers[2],
                      //&pp= &flowers[2]自体の場所
  printf("%s\n", *pp );　//間接参照した先は、PANSYのアドレス情報flowers[2]なのでPANSYと表示
  printf("%s\n", *(pp + 1) );  //ppはchar**型なので、&flowers[2+1]と考えて良い。よってLILY。
                              //ちなみに（pp + 1）と*を付け忘れると、char型のアドレス情報期待するところにﾎﾟｲﾝﾀのアドレス情報が来てエラー
  printf("%c\n", **pp );    //**ppの先は、printf()ではコピーに計算しただけなので、変数ppの変更はない。よって参照先'P'が%cで表示
  return 0;
}
//1011_p-47-Q6
#include<stdio.h>
int main(void)
{
  char *color[] = {"YELLOW","RED","BLUE","GREEN","BLACK","WHITE"};
  char *p;
  char **pp;

  p = color[4];
  printf("%s\n", p ); //BLACK

  p++;
  printf("%s\n", p ); //LACK

  pp = color; //==&color[0]==color[0]
  printf("%s\n", *pp + 2 ); // *pp=p=color[0] LLOW
  printf("%s\n", *( pp + 2 )); // BLUE

  pp += 3; //GREEN
  printf("%c\n", *( *pp + 1 ) ); color[4]+1 R
  return 0;
}























